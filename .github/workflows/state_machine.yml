name: State Machine Enforcement

on:
  issue_comment:
    types: [created]
  issues:
    types: [labeled]

permissions:
  issues: write
  contents: read

jobs:
  handle_slash_command:
    name: Handle Slash Commands
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && startsWith(github.event.comment.body, '/')
    
    steps:
      - name: Parse Command
        id: parse
        run: |
          COMMENT="${{ github.event.comment.body }}"
          COMMAND=$(echo "$COMMENT" | head -n 1 | grep -oP '^/\w+' | sed 's/\///')
          ARGS=$(echo "$COMMENT" | head -n 1 | sed 's/^\/\w\+//' | xargs)
          
          echo "command=$COMMAND" >> $GITHUB_OUTPUT
          echo "args=$ARGS" >> $GITHUB_OUTPUT
          echo "actor=${{ github.event.comment.user.login }}" >> $GITHUB_OUTPUT
          echo "issue_number=${{ github.event.issue.number }}" >> $GITHUB_OUTPUT

      - name: Get Current State
        id: current_state
        uses: actions/github-script@v7
        with:
          script: |
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const stateLabel = issue.data.labels.find(l => l.name.startsWith('state:'));
            const currentState = stateLabel ? stateLabel.name : 'none';
            const assignee = issue.data.assignee ? issue.data.assignee.login : null;
            
            core.setOutput('current_state', currentState);
            core.setOutput('assignee', assignee || 'none');

      - name: Validate and Execute Transition
        id: transition
        uses: actions/github-script@v7
        with:
          script: |
            const command = '${{ steps.parse.outputs.command }}';
            const args = '${{ steps.parse.outputs.args }}';
            const currentState = '${{ steps.current_state.outputs.current_state }}';
            const currentAssignee = '${{ steps.current_state.outputs.assignee }}';
            const actor = '${{ steps.parse.outputs.actor }}';
            
            const transitions = {
              'claim': {
                from: ['state: ready-for-implementation'],
                to: 'state: implementing',
                requiresUnassigned: true,
                assignToActor: true
              },
              'state': {
                'testing': {
                  from: ['state: implementing'],
                  to: 'state: testing',
                  requiresAssignedToActor: true
                },
                'triaged': {
                  from: ['state: discovered'],
                  to: 'state: triaged'
                }
              }
            };
            
            let transition = null;
            let newState = null;
            let valid = false;
            let errorMessage = '';
            
            if (command === 'claim') {
              transition = transitions[command];
              newState = transition?.to;
            } else if (command === 'state' && args) {
              transition = transitions.state[args];
              newState = transition?.to;
            }
            
            if (!transition) {
              errorMessage = `Unknown command: /${command} ${args}`;
            } else {
              if (!transition.from.includes(currentState)) {
                errorMessage = `Cannot transition from ${currentState} to ${newState}`;
              } else if (transition.requiresUnassigned && currentAssignee !== 'none') {
                errorMessage = `Task already assigned to @${currentAssignee}`;
              } else if (transition.requiresAssignedToActor && currentAssignee !== actor) {
                errorMessage = `Only @${currentAssignee} can perform this action`;
              } else {
                valid = true;
              }
            }
            
            if (!valid) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `❌ Invalid transition: ${errorMessage}`
              });
              core.setFailed(errorMessage);
              return;
            }
            
            if (currentState !== 'none') {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: currentState
                });
              } catch (error) {
                console.log(`Warning: Could not remove label`);
              }
            }
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [newState]
            });
            
            if (transition.assignToActor) {
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                assignees: [actor]
              });
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `✅ State transition: ${currentState} → ${newState}`
            });
            
            core.setOutput('success', 'true');
            core.setOutput('new_state', newState);
